# Import necessary modules
from flask import Flask, render_template, request, send_from_directory  # Flask framework for web app
import random  # To generate random numbers
import boto3  # AWS SDK to interact with Bedrock and S3
import json  # JSON handling
import base64  # Encoding and decoding images to/from base64
import io  # Handling in-memory binary data
from PIL import Image  # Image processing
import pandas as pd  # Data analysis (for handling CSV files)
import time
app = Flask(__name__)

MODEL_TEXT_BASIC = 'anthropic.claude-3-5-haiku-20241022-v1:0'
MODEL_TEXT_COMPLEX = 'anthropic.claude-3-5-sonnet-20240620-v1:0'
MODEL_IMAGE='stability.sd3-large-v1:0'
REGION='us-west-2'
# Initialize AWS Bedrock client
bedrock_client = boto3.client(service_name='bedrock-runtime',region_name=REGION)

#### BEDROCK FUNCTIONS

def get_content_from_model(body,model_id):
    """Extract text content from the model response."""
    response = []
    # Parse the JSON body of the response
    response_body = json.loads(body.get("body").read())
    # Iterate through the content items


    if 'anthropic' in model_id: 
        for m in response_body["content"]:
            # If the content type is text, add it to the response
            if m["type"] == "text":
                response.append(m["text"])
        # Join all text content into a single string
        return "".join(response)
    elif 'nova' in model_id:
        for m in response_body["output"]["message"]["content"]:
            response.append(m["text"])
    # Join all text content into a single string
        return "".join(response)
    else:
        return "Unknown model"

def generate_image_with_bedrock(prompt, model_id):
    """Generate an image using Amazon Bedrock and save it locally."""
    # Prepare the request body with the prompt
    print ("Generating image with prompt: " + prompt + "Model: " + model_id)
    if 'stability' in model_id: 
        body = json.dumps({
            'prompt': prompt 
        })
    elif 'nova' in model_id:
        body = json.dumps({
            "taskType": "TEXT_IMAGE",
            "textToImageParams": {
                "text": prompt
            },
            "imageGenerationConfig": {
                "numberOfImages": 1,
                "height": 1024,
                "width": 1024,
                "cfgScale": 8.0,
                "seed": 0
            }
        })
    else:
        return "Generate image with bedrock: Invalid model id"

    # Invoke the Bedrock model
    response = bedrock_client.invoke_model(
        modelId=model_id,
        body=body,
        contentType='application/json',
    )
    
    # Parse the response and extract the base64 encoded image
    output_body = json.loads(response["body"].read().decode("utf-8"))
    base64_output_image = output_body["images"][0]
    
    # Decode the base64 image
    image_data = base64.b64decode(base64_output_image)
    image = Image.open(io.BytesIO(image_data))

    # Generate a random number for unique filename
    random_number = random.randint(1000, 999999)

    # Create the image location string with the random number
    imagelocation = f"generated_images/image{random_number}.png"

    # Save the image to the specified location
    image.save(imagelocation)
    time.sleep(5)
    return imagelocation



def check_image(prompt, model_id, existing_image):
    """
    Analyze an AI-generated image for a marketing campaign using Amazon Bedrock.

    This function sends the image and its generating prompt to an AI model for analysis,
    focusing on identifying inaccuracies or unrealistic elements and suggesting improvements.

    Args:
        prompt (str): The original prompt used to generate the image.
        model_id (str): The ID of the Amazon Bedrock model to use for analysis.
        existing_image (str): Path to the image file to be analyzed.

    Returns:
        str: The analysis result from the AI model.
    """
    MAX_TOKENS = 1000

    # Construct the analysis question
    analysis_question = f"""
    Here is an image generated by an AI model. It was generated by an AI model.  
    The prompt that generated it was: {prompt}

    Its purpose is to be sent out as part of a marketing campaign. It needs to be realistic and accurate. 

    Your job is to point out any inaccuracies or unrealistic elements of the image. 
    For example, an image with snow in Egypt would be unlikely. 

    Lastly, can you use suggest an improved prompt to pass to the image generation AI model. 
    """

    # Encode the image to base64
    base64_string = encode_image(existing_image)

    if 'anthropic' in model_id:
        # Prepare the message for the model
        message = {
            "role": "user",
            "content": [
                {"type": "image", "source": {"type": "base64", "media_type": "image/jpeg", "data": base64_string}},
                {"type": "text", "text": analysis_question}
            ]
        }

        # Prepare the body for the API request
        body = json.dumps({
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": MAX_TOKENS,
            "messages": [message],
        })
    elif 'nova' in model_id:
        message = {
        "role": "user",
        "content": [
            {
                "image": {
                    "format": "png",
                    "source": {
                        "bytes": base64_string
                    }
                }
            },
            {
                "text": analysis_question
            }
        ]
        }


        # Prepare the body for the API request
        body = json.dumps({

            "messages": [message],
        })
    else:
        return "Check image - Invalid model ID"

    # Invoke the Bedrock model
    response = bedrock_client.invoke_model(
        modelId=model_id,
        body=body,
        contentType='application/json',
    )
    time.sleep(5)

    # Extract and return the content from the model's response
    return get_content_from_model(response,model_id)


def generate_image_variation(prompt, model_id, existing_image, strength):
    """
    Generate a variation of an existing image using Amazon Bedrock.

    This function takes an existing image and generates a variation based on the given prompt
    and strength parameter.

    Args:
        prompt (str): The prompt to guide the image variation.
        model_id (str): The ID of the Amazon Bedrock model to use for image generation.
        existing_image (str): Path to the existing image file.
        strength (float): The strength of the variation (likely a value between 0 and 1).

    Returns:
        None: The function saves the generated image, overwriting the existing image file.
    """
    # Read and encode the existing image
    with open(existing_image, "rb") as image_file:
        init_image = base64.b64encode(image_file.read()).decode('utf8')

    if 'stability' in model_id:
        # Prepare the body for the API request
        body = json.dumps({
            "prompt": prompt,
            "mode": 'image-to-image',
            "image": init_image,
            "strength": strength
        })
    elif 'nova' in model_id:
        body = json.dumps({
            "taskType": "IMAGE_VARIATION",
            "imageVariationParams": {
                "text": prompt,
                "images": [init_image],
                "strength": strength
            },
            "imageGenerationConfig": {
                "numberOfImages": 1,
                "height": 1024,
                "width": 1024,
                "cfgScale": 8.0,
                "seed": 0
            }
        })


    # Invoke the Bedrock model
    response = bedrock_client.invoke_model(
        modelId=model_id,
        body=body,
        contentType='application/json',
    )

    # Parse the response and extract the generated image
    output_body = json.loads(response["body"].read().decode("utf-8"))
    base64_output_image = output_body["images"][0]
    image_data = base64.b64decode(base64_output_image)
    image = Image.open(io.BytesIO(image_data))

    # Save the generated image, overwriting the existing image
    image.save(existing_image)
    time.sleep(5)


def generate_with_bedrock(prompt, model_id):
    """
    Generate text content using Amazon Bedrock.

    This function sends a prompt to a specified Bedrock model and returns the generated content.

    Args:
        prompt (str): The prompt to send to the model.
        model_id (str): The ID of the Amazon Bedrock model to use.

    Returns:
        str: The generated content from the model.
    """
    MAX_TOKENS = 1000
    print ("Running with Prompt: " + prompt + "Model ID: " + model_id)
    if 'anthropic' in model_id:
        # Prepare the message for the model
        message = {
            "role": "user",
            "content": [
                {"type": "text", "text": prompt},
            ],
        }

        # Prepare the body for the API request
        body = json.dumps({
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": MAX_TOKENS,
            "messages": [message],
        })
    elif 'nova' in model_id:
        # Prepare the question for the model
        question = {
            "role": "user",
            "content": [
                { "text": prompt},
            ],
        }

        # Prepare the body for the API request
        body = json.dumps({
            "messages": [question],
        })

    else:
        return "Generate with Bedrock - Invalid model ID" + model_id


    # Invoke the Bedrock model
    response = bedrock_client.invoke_model(
        modelId=model_id,
        body=body,
        contentType='application/json',
    )
    time.sleep(5)

    # Extract and return the content from the model's response
    return get_content_from_model(response,model_id)








#### OTHER LOGIC 




def encode_image(img_file):
    """Encode an image file to base64 string."""
    with open(img_file, "rb") as image_file:
        # Read the image file and encode it to base64
        img_str = base64.b64encode(image_file.read())
        # Convert the bytes to a UTF-8 string
        base64_string = img_str.decode("utf-8")
    return base64_string


def pick_image(imagecatalog, headlines, blurbs):
    """
    Select up to three images from a catalog that best match given headlines and blurbs.

    This function uses Amazon Bedrock to analyze an image catalog and select images
    that are most relevant to the provided marketing content.

    Args:
        imagecatalog (str): A JSON string representing the image catalog.
        headlines (str): The headlines of the marketing content.
        blurbs (str): The blurbs or detailed content of the marketing material.

    Returns:
        str: A JSON string containing up to three selected image URLs.
    """
    # Construct the prompt for image selection
    prompt = f"""
    Here is a JSON dictionary that describes a number of images from an image catalog. The image URL is the key, and the description and tags describe what is in the image. 
    {imagecatalog}
    Your job is to pick an image from the given dictionary that applies best to the following headline and blurb:
    Headline: {headlines}
    Blurb:  {blurbs}

    The image URL must be exactly as given in the image catalog. You must not change the image URL. 

    You may only pick up to a maximum of 3 images and should return the image URL.     
    You must ensure that you return valid JSON. You should only return the JSON, with no other description, commentary or annotations. 

    You should respond in the following format with no other information, annotations or descriptions:
    {{
        "imagepicked1,": "image URL",
        "imagepicked2,": "image URL",
        "imagepicked3,": "image URL"      
    }}
    """

    # Generate response using Amazon Bedrock
    bedrock_response = generate_with_bedrock(prompt, MODEL_TEXT_COMPLEX)
    return bedrock_response


# Function to generate headlines
def generate_headlines(theme, partner_type, targeting_themes):
    """
    Generate marketing headlines based on given campaign parameters.

    This function uses Amazon Bedrock to create 3 creative and catchy headlines
    for a marketing campaign.

    Args:
        theme (str): The main theme of the marketing campaign.
        partner_type (str): The type of partner for the campaign.
        targeting_themes (str): A comma-separated string of targeting themes.

    Returns:
        list: A list of 3 generated headlines.
    """
    # Split targeting themes into a list
    themes = targeting_themes.split(',')

    # Construct the prompt for headline generation
    prompt = f"Generate 3 marketing headlines for a campaign with the theme '{theme}' for a partner that is a {partner_type}. Targeting themes: {targeting_themes}. Provide creative and catchy headlines. Respond with one headline per line with no other annotations. Ensure there is a line break between headlines."
    
    # Generate response using Amazon Bedrock
    bedrock_response = generate_with_bedrock(prompt, MODEL_TEXT_BASIC)
    
    # Split the response into individual headlines
    headlines = bedrock_response.split("\n\n")  # Assuming newline separated headlines
    return headlines  

# Function to generate marketing blurbs
def generate_blurbs(theme, partner_type, targeting_themes):
    """
    Generate marketing blurbs based on given campaign parameters.

    This function uses Amazon Bedrock to create 3 short, creative paragraphs
    for a marketing campaign.

    Args:
        theme (str): The main theme of the marketing campaign.
        partner_type (str): The type of partner for the campaign.
        targeting_themes (str): A comma-separated string of targeting themes.

    Returns:
        list: A list of 3 generated blurbs.
    """
    # Split targeting themes into a list
    themes = targeting_themes.split(',')

    # Construct the prompt for blurb generation
    prompt = f"Generate 3 different paragraphs for a marketing blurb. These paragraphs should be short - only 2 sentences. The campaign has the theme '{theme}' for a partner that is a {partner_type}. Targeting themes: {targeting_themes}. Provide creative and catchy blurb. Provide one blurb per line with no other information or annotations"
    
    # Generate response using Amazon Bedrock
    bedrock_response = generate_with_bedrock(prompt, MODEL_TEXT_BASIC)
    
    # Split the response into individual blurbs
    blurbs = bedrock_response.split("\n\n")  # Assuming newline separated blurbs
    return blurbs

# Function to generate image 
def generate_image_urls(theme, partner_type, targeting_themes, existing_headlines):
    """
    Generate prompts for AI image generation and create images based on campaign parameters.

    This function uses Amazon Bedrock to create prompts for image generation,
    then uses these prompts to generate images using a separate AI model.

    Args:
        theme (str): The main theme of the marketing campaign.
        partner_type (str): The type of partner for the campaign.
        targeting_themes (str): A comma-separated string of targeting themes.
        existing_headlines (list): A list of existing headlines for the campaign.

    Returns:
        list: A list of dictionaries, each containing information about a generated image.
    """
    # Split targeting themes into a list
    themes = targeting_themes.split(',')
    
    # Combine existing headlines into a single string
    existing_headlines_strings = ''.join(existing_headlines)
    
    # Construct the prompt for image prompt generation
    prompt = f"I need a prompt to create images using an AI image generator. I require 3 images. They need to be realistic images. I don't want to include any overlay text. The campaign has the theme '{theme}' for a partner that is a {partner_type}. Targeting themes: {targeting_themes}. Existing headlines are {existing_headlines_strings}. Provide the prompts with no other text or information. Do not give a line number or any punctuation. Give one prompt per line."

    # Generate response using Amazon Bedrock
    bedrock_response = generate_with_bedrock(prompt, MODEL_TEXT_BASIC)
    
    # Split the response into individual image prompts
    image_prompts = bedrock_response.split("\n")  # Assuming newline separated prompts
    
    images = []
    for prompt in image_prompts:
        if len(prompt) < 10:
            # Skip prompts that are too short to be meaningful
            print("Too short")
        else:
            # Log the prompt being used
            print("Prompt: " + prompt)
            # Generate image using the prompt
            imagelocation = generate_image_with_bedrock(prompt, MODEL_IMAGE)
            # Check the realism of the generated image
            realism_check = check_image(prompt, MODEL_TEXT_COMPLEX, imagelocation)
            
            # Store information about the generated image
            images.append({"prompt": prompt, "image_location": imagelocation, "realism": realism_check})
    
    return images


def ammend_image(prompt, image, strength):
    """
    Amend an existing image based on a given prompt.

    Args:
        prompt (str): The text prompt to guide the image amendment.
        image (str): The filename or path of the image to be amended.
        strength (float): The strength of the amendment effect (likely a value between 0 and 1).

    Returns:
        None

    Note:
        This function prints a status message and calls the generate_image_variation function.
        The actual image generation is handled by the generate_image_variation function.
    """
    print(f"Amending {image} with {prompt}")
    generate_image_variation(prompt, MODEL_IMAGE, image, strength)

# Dictionary mapping routes to their respective directories
DIRECTORIES = {
    'generated_images': 'generated_images',  # Directory for generated images
    'imagecatalog': 'imagecatalog'           # Directory for image catalog
}

@app.route('/<directory>/<path:filename>')
def serve_file(directory, filename):
    """
    Serve a file from a specified directory.

    This Flask route handler serves files from predefined directories.
    It checks if the requested directory is valid and then attempts to serve the file.

    Args:
        directory (str): The name of the directory to serve from (must be in DIRECTORIES).
        filename (str): The name of the file to serve.

    Returns:
        file: The requested file if found.
        404: If the directory is invalid or the file is not found.

    Note:
        This function uses Flask's send_from_directory to serve files securely.
    """
    # Check if the directory is valid
    if directory in DIRECTORIES:
        # Serve the file from the corresponding directory
        try:
            return send_from_directory(DIRECTORIES[directory], filename)
        except FileNotFoundError:
            abort(404)  # File not found
    else:
        abort(404)  # Invalid directory



@app.route("/", methods=["GET", "POST"])
def index():
    """
    Main route handler for the application.
    
    This function handles both GET and POST requests to the root URL.
    For GET requests, it renders the template with empty values.
    For POST requests, it processes form data to generate marketing content.
    
    Returns:
        rendered template: The HTML page with generated marketing content.
    """
    friendly_model_name=None

    if request.method == "POST":
        # Handle POST requests
        action = request.form.get("action")
        global MODEL_TEXT_BASIC, MODEL_TEXT_COMPLEX, MODEL_IMAGE, REGION, bedrock_client
        
        # Configure AI models based on the selected action
        if action == 'newnova':
            # Use Amazon Nova models
            MODEL_TEXT_BASIC = 'amazon.nova-lite-v1:0'
            MODEL_TEXT_COMPLEX = 'amazon.nova-pro-v1:0'
            MODEL_IMAGE='amazon.nova-canvas-v1:0'
            REGION='us-east-1'
            # Initialize AWS Bedrock client
            bedrock_client = boto3.client(service_name='bedrock-runtime',region_name=REGION)
            friendly_model_name="Nova"
        else:
            # Use Anthropic Claude and Stability models (default)
            MODEL_TEXT_BASIC = 'anthropic.claude-3-5-haiku-20241022-v1:0'
            MODEL_TEXT_COMPLEX = 'anthropic.claude-3-5-sonnet-20240620-v1:0'
            MODEL_IMAGE='stability.sd3-large-v1:0'
            REGION='us-west-2'
            friendly_model_name="Claude/Stability"
            # Initialize AWS Bedrock client
            bedrock_client = boto3.client(service_name='bedrock-runtime',region_name=REGION)
                       
        if action == 'new' or action == 'newnova':
            # Handle new campaign generation
            
            # Get form inputs for campaign parameters
            theme = request.form.get("theme")
            partner_type = request.form.get("partner_type")
            targeting_themes = request.form.get("targeting_themes")
     
            # Generate marketing content using AI models
            headlines = generate_headlines(theme, partner_type, targeting_themes)
            blurbs = generate_blurbs(theme, partner_type, targeting_themes)

            # Load and process image catalog to find relevant images
            file_path = 'imagecatalog.json'
            with open(file_path, 'r') as file:
                loaded_data = json.load(file)
            bestimagejson = pick_image(json.dumps(loaded_data), headlines, blurbs)
            print(bestimagejson)
            bestimage = json.loads(bestimagejson)
            # Extract valid image URLs from the response
            image_list = [value for value in bestimage.values() if value]
            
            # Generate new AI images based on campaign parameters
            images = generate_image_urls(theme, partner_type, targeting_themes, headlines)
            
            # Extract and organize image information for the template
            image_locations = [image['image_location'] for image in images]
            prompts_dict = {image['image_location']: image['prompt'] for image in images}
            realism_dict = {image['image_location']: image['realism'] for image in images}
            
            # Render template with all generated content
            return render_template("index-combined.html", 
                                   headlines=headlines, 
                                   blurbs=blurbs, 
                                   images=image_locations,
                                   prompts=prompts_dict,
                                   theme=theme,
                                   partner_type=partner_type,
                                   targeting_themes=targeting_themes,
                                   realisms=realism_dict,
                                   chosen_image=image_list, 
                                   friendly_model_name=friendly_model_name)
        
        elif action == 'reimage':
            # Handle image regeneration/refinement
            print("Running a reimage")
            
            # Collect submitted prompts from the form
            submitted_prompts = {}
            for key, value in request.form.items():
                if key.startswith('prompts['):
                    image_location = key[8:-1]  # Strip 'prompts[' and ']'
                    submitted_prompts[image_location] = value
            
            # Get form inputs to maintain campaign context
            theme = request.form.get("theme")
            partner_type = request.form.get("partner_type")
            targeting_themes = request.form.get("targeting_themes")
            headlines = request.form.getlist("headlines")
            blurbs = request.form.getlist("blurbs")
            images = request.form.getlist("images")
            imageid = request.form.get("imageid")
            full_imageid = request.form.get("newimageid")
            
            # Determine image generation strength and target image ID
            # Higher strength means more significant changes to the image
            strength = 0.9  # Default strength
            if imageid:
                strength = 0.8  # Moderate changes
                definedimageid = imageid
            if full_imageid:
                strength = 1  # Complete regeneration
                definedimageid = full_imageid
            
            # Amend the image with the new prompt
            ammendprompt = submitted_prompts[definedimageid]
            ammend_image(ammendprompt, definedimageid, strength)
            
            # Render template with updated content
            return render_template("index-combined.html", 
                                   headlines=headlines, 
                                   blurbs=blurbs, 
                                   images=images,
                                   prompts=submitted_prompts,
                                   theme=theme,
                                   partner_type=partner_type,
                                   targeting_themes=targeting_themes,
                                   realisms=None,
                                   chosen_image=None,
                                   friendly_model_name=friendly_model_name)

    # Handle GET requests - render empty template
    return render_template("index-combined.html", 
                           headlines=None, 
                           blurbs=None, 
                           images=None,
                           theme=None,
                           partner_type=None,
                           targeting_themes=None,
                           chosen_image=None,
                           friendly_model_name=friendly_model_name)


if __name__ == "__main__":
    # Run the Flask application
    # debug=True enables auto-reloading when code changes
    # port=5001 sets the application to run on port 5001
    # host='0.0.0.0' makes the server publicly available on the network
    app.run(port=5001, host='0.0.0.0')
